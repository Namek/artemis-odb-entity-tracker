<style>
body {
	font-family: sans-serif;
}
figure img {
	border: 1px solid black;
	padding: 0.5em;
	width: 50%;
}
</style>

<h1>Entity Tracker</h1>

<p>A game debugger of a <a href="https://github.com/junkdog/artemis-odb">artemis-odb</a> World state, working over the network. Artemis is an <a href="https://github.com/junkdog/artemis-odb/wiki/Concepts">Entity Component Systems</a> framework for games, written in Java.</p>

<p>The <strong>Entity Tracker</strong> consists of two things:</p>
<ol>
<li>the <strong>library</strong> that should be injected to a game - it tracks the ECS World</li>
<li>the external UI displaying all the entities and components</li>
</ol>

<p>Both communicate over TCP.</p>

<p>To read "what, why, what for?" explanations head over to my <strong>blog</strong>:<br> â†’ <a href="https://namekdev.net/2017/03/artemis-entity-tracker-inspecting-your-game-state-through-network/">Artemis Entity Tracker - inspecting your game state through network</a></p>
<p>which is based on a previous (and much simpler) iteration of the Entity Tracker</p>

<p>

<h2>Features</h2>

<ul>
<li>View state of any component of any entity in the game, values updating in real time
<li>Modify state of components in real time
<li>Filter entities by specific component types and/or systems. Per-component filter modes: Include [+], Exclude [-], Doesn't Matter [ ]
<li>Toggle Systems and Managers
<li>Additional layout mode for a lot of component types (very wide entity list)
</ul>


<h3>Feature Wishlist</h3>

<ul>
<li>adding/removing entity components
<li>marking entities I want to track, getting noticed when they get destroyed
<li>searching for entities having certain values
<li>remembering component states on timeline for diffing those later
<li>pausing the world
<li>calling in-game procedures written by user and registered to the debugger
</ul>

<h2>Screenshots</h1>

<figure>
<a href="img/filtering by component type and picking components.gif">
	<img src="img/filtering by component type and picking components.gif" >
	<figcaption>Filtering entities by component type and picking components</figcaption>
</a>
</figure>


<figure>
<a href="img/changing values.gif">
	<img src="img/changing values.gif" width="50%">
	<figcaption>Changing values of component fields</figcaption>
</a>
</figure>

<figure>
<a href="img/Additional layout mode for a lot of components.gif">
	<img src="img/Additional layout mode for a lot of components.gif" >
	<figcaption>Additional layout mode for a lot of component types</figcaption>
</a>
</figure>


<h2>Technical awesomeness</h2>

<p>It has totally <u>custom homemade Java <strong>serializer</strong></u> which deserializes into a <strong>Value Tree</strong> structure, similar to JSON but <strong>binary</strong>. It doesn't deserialize into original in-game types because the UI doesn't have them. Thus, the serializer on the Library side does not need any configuration besides injecting the <strong>EntityTracker</strong> object into the Artemis <strong>World</strong>. However, it keeps information about types of classes and fields so it's something more than JSON.</p>

<p>It's written in Kotlin. The library compiles to Java lib, the UI builds into a HTML + JavaScript.</p>

<h3>The hard parts</h3>

<ul>
<li>UI implementation is inspired by the <a href="https://package.elm-lang.org/packages/mdgriffith/elm-ui/latest/">elm-ui</a>. Virtual DOM is a complete (JavaScript to Kotlin) rewrite of the <a href="https://github.com/snabbdom/snabbdom">snabbdom</a> library. So I stole two libraries and joined those together with some additional bits on my side to track the changes of data.
<li>the entity list has a virtual scrolling which means it renders only the entities that are visible due to list scrolling. This was made with Canvas 2D instead of some DOM trickery. Thus, custom scrolling, spacing and so on. Not really easy in practice, a total surprise here.
<li>the Serializer brought <a href="https://namekdev.net/tags/serializing-java/">challenges</a>. Supports <a href="https://namekdev.net/2017/05/serializing-java-cyclic-dependencies/">full recurrency</a>, both in objects and types. I recommend reading <a href="https://namekdev.net/tags/serializing-java/">the Serializing Java series</a> on my blog to appreciate it.
</ul>

<h3>The story of huge refactor</h3>

<p>Originally, the interface was made with Java Swing. Swing was buggy, took lots of time on every small change in layout design and internals of Java Swing seemed to create lots of memory garbage. I was somewhat OK with performance only for a small projects. However, I totally didn't felt OK with the speed of development. I wished for declarative UI. So I did few things:</p>

<ul>
<li>moved from Java to Kotlin</li>
<li>refactored everything to kotlin-common which enabled me to build both JVM server and JavaScript client</li>
<li>ported snabbdom (Virtual DOM library) and elm-ui to Kotlin and coupled them together
This was a tough decision since it's no more possible to run UI within a game process. On the other hand, it felt very convenient when I had to only restart the game during development and debugger was already there, waiting in the background. So now everything is sent over network which was just an option before.</li>
</ul>

Now the speed of development seems not much better since we have a almost-declarative UI in an <i>imperative</i> language. The biggest drawback though, is the Kotlin to JavaScript compilation, it's just pretty slow as for Kotlin 1.3.50.
