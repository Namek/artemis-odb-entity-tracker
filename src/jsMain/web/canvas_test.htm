<!doctype html>

<div id="container">
</div>
<br>
<button onclick="removeEntites(10)">remove 10 entities</button>
<button onclick="removeEntites(100)">remove 100 entities</button>
<button onclick="removeEntites(480)">remove 480 entities</button>
<button onclick="removeEntites(10, true)">shift 10 entities</button>

<script>
// ultra simple auto-reload!
(() => {
  const watchClassTag = 'watch-for-auto-reload'
  const firstCheckDelay = 100
  const checksDelay = 500
  const additionalFilesToWatch = [
  ]
  const consoleLoggingEnabled = true


  function startCheckingFile(href) {
    const state = { lastModified: null }
    const isStyle = href.indexOf('.css') == href.length - 4

    // ask server about every 500ms for the file
    setInterval(() => {
      let xhr = new XMLHttpRequest()
      xhr.open("HEAD", href + '?beat-the-cache=' + new Date().getTime())
      xhr.send(null)

      xhr.onload = e => {
        const lastModified = xhr.getResponseHeader("last-modified")

        if (state.lastModified === null) {
          state.lastModified = lastModified

          if (consoleLoggingEnabled)
            console.log('watching file: ' + href + ', date: ' + lastModified)
        }
        else if (state.lastModified != lastModified) {
          state.lastModified = lastModified

          if (consoleLoggingEnabled)
            console.log('file changed: ' + href)

          if (isStyle) {
            replaceStylesheet(href)
          }
          else {
            location.reload()
          }
        }
      }
    }, checksDelay)
  }

  function replaceStylesheet(filename) {
    document.querySelectorAll('link').forEach(link => {
      if (link.href.indexOf(filename) < 0)
        return

      const queryString = '?beat-the-cache=' + new Date().getTime()
      link.href = link.href.replace(/\?.*|$/, queryString)
    })
  }

  setTimeout(() => {
	startCheckingFile(document.URL)
  
    document.querySelectorAll('.' + watchClassTag)
      .forEach(link => startCheckingFile(link.href))

    additionalFilesToWatch
      .forEach(startCheckingFile)

  }, firstCheckDelay)
})()
</script>

<style rel="stylesheet" type="text/css">
#container {
	width: 400px;
	height: 50vh;
}
#canvas {
	outline: 1px solid steelblue;
}
</style>

<script>
var PIXEL_RATIO = (function () {
    var ctx = document.createElement("canvas").getContext("2d"),
        dpr = window.devicePixelRatio || 1,
        bsr = ctx.webkitBackingStorePixelRatio ||
              ctx.mozBackingStorePixelRatio ||
              ctx.msBackingStorePixelRatio ||
              ctx.oBackingStorePixelRatio ||
              ctx.backingStorePixelRatio || 1;

    return dpr / bsr;
})();

createHiDPICanvas = function(w, h, ratio) {
    if (!ratio) { ratio = PIXEL_RATIO; }
    var can = document.createElement("canvas");
    can.width = w * ratio;
    can.height = h * ratio;
    can.style.width = w + "px";
    can.style.height = h + "px";
    can.getContext("2d").setTransform(ratio, 0, 0, ratio, 0, 0);
    return can;
}

const container = document.getElementById("container")
const containerSize = getContainerSize()
const canvas = createHiDPICanvas(containerSize.width, containerSize.height)
container.appendChild(canvas)
const ctx = canvas.getContext("2d")

const r = 1/PIXEL_RATIO
var canvasWidth = canvas.width*r, canvasHeight = canvas.height*r

function getContainerSize() {
	const compStyles = window.getComputedStyle(container);
	return {
		width: Math.round(compStyles.width.substr(0, compStyles.width.length - 2)),
		height: Math.round(compStyles.height.substr(0, compStyles.height.length - 2))
	}
}
function refreshCanvasSize(canvas) {
	const size = getContainerSize()
	canvas.width = size.width * PIXEL_RATIO
	canvas.height = size.height * PIXEL_RATIO
	canvas.style.width = size.width + "px"
	canvas.style.height = size.height + "px"
	canvas.getContext("2d").setTransform(PIXEL_RATIO, 0, 0, PIXEL_RATIO, 0, 0);
	canvasWidth = canvas.width*r
	canvasHeight = canvas.height*r
}
setTimeout(() => {
	//refreshCanvasSize(canvas)
	render()
})

window.addEventListener('resize', () => {
	
	window.requestAnimationFrame(() => {
		refreshCanvasSize(canvas)
		render()
	})
})

function c(num) {
	var text = "", i = 0
	while (i++ < num)
		text += (Math.random() < 0.5 ? 1 : 0)
		
	return text
}



const rowsGap = 7, colsGap = 10
const minScrollHeight = 20, scrollWidth = 15, crossSize = 8
const rowYPadding = 3, rowHeight = crossSize + rowYPadding
const scrollContainerPadding = 2
const hoverMargin = 3

var componentTypesCount = 8
var entityComponents = [...Array(500).keys()]
	.map(i => ({ entityId: i, components: "1" + c(componentTypesCount-1) }))
	
function removeEntites(num, fromTop) {
	for (let i = 0; i < num; ++i)
		entityComponents[fromTop ? 'shift' : 'pop']()

	// maintain same index position if possible
	const visibleRowsCountFractioned = (canvasHeight+rowsGap) / (rowHeight+rowsGap)
	
	// TODO still moves... omg
	const oldPosForNewEntityCount = scroll.firstEntityIndexWithTranslation / (entityComponents.length  - visibleRowsCountFractioned)
	setScrollPos(oldPosForNewEntityCount)
}

const scroll = {
	pos: 0, // percent [0..1]
	firstEntityIndexWithTranslation: 0,
	shouldRender: false,
	top: 0, left: 0, right: 0, bottom: 0,
	containerTop: 0, containerLeft: 0, containerWidth: 0, containerHeight: 0,
	isDragged: false, dragOffsetY: 0,
	isFocused: false
}
const hover = {
	lastMousePosX: 0, lastMousePosY: 0
}
setScrollPos(1)

canvas.addEventListener('mousedown', (e) => {
	const x = e.offsetX, y = e.offsetY
	
	if (scroll.shouldRender) {
		if (x > scroll.left && x < scroll.right && y > scroll.top && y < scroll.bottom) {
			scroll.dragOffsetY = y - scroll.top
			scroll.isDragged = true
		}
	}
})
canvas.addEventListener('mousemove', (e) => {
	const x = e.offsetX, y = e.offsetY
	
	if (x > scroll.left && x < scroll.right && y > scroll.top && y < scroll.bottom) {	
		scroll.isFocused = true
	}
	
	if (hover.lastMousePosX != x || hover.lastMousePosY != y) {
		hover.lastMousePosX = x
		hover.lastMousePosY = y
		requestAnimationFrame(render)
	}
})
canvas.addEventListener('mouseleave', (e) => {
	hover.lastMousePosX = -1
	hover.lastMousePosY = -1
})
canvas.addEventListener('click', (e) => {
	const x = e.offsetX, y = e.offsetY
	
	const scrollAreaButNotScrollEl = x > scroll.left && x < scroll.right && !(y > scroll.top && y < scroll.bottom)
	if (scrollAreaButNotScrollEl) {
		scroll.dragOffsetY = scroll.height / 2
		
		const localY = e.clientY - canvas.getBoundingClientRect().top
		
		setScrollPos(
			(localY - scroll.containerTop - scroll.dragOffsetY) / (scroll.containerHeight - scroll.height)
		)
		
		requestAnimationFrame(render)
	}
	
	// TODO click entity component
})
window.addEventListener('mouseup', (e) => {
	scroll.isDragged = false
})
window.addEventListener('mousemove', (e) => {
	if (scroll.isDragged) {
		e.preventDefault()
		const localY = e.clientY - canvas.getBoundingClientRect().top
		
		setScrollPos(
			(localY - scroll.containerTop - scroll.dragOffsetY) / (scroll.containerHeight - scroll.height)
		)
	}
})
canvas.addEventListener('wheel', (e) => {
	setScrollPos(scroll.pos + Math.sign(e.deltaY) * 200 / (entityComponents.length * (rowHeight+rowsGap)))
})
function setScrollPos(pos) {
	scroll.pos = Math.min(1, Math.max(0, pos))
	const entityCount = entityComponents.length
	const visibleRowsCountFractioned = (canvasHeight) / (rowHeight+rowsGap) // the denominator seems bad. that many `rowsGap` is too much
	
	// TODO well in some cases last element is still cut or invisible...
	scroll.firstEntityIndexWithTranslation = (entityCount - Math.floor(visibleRowsCountFractioned) + visibleRowsCountFractioned % 1 - 1) * scroll.pos
	
	window.requestAnimationFrame(render)
}

function render() {
	ctx.clearRect(0, 0, canvasWidth, canvasHeight);

	const entityCount = entityComponents.length
	const visibleRowsCountFractioned = (canvasHeight+rowsGap) / (rowHeight+rowsGap)
	const visibleRowsCount = Math.ceil(visibleRowsCountFractioned)
	const maxScrollHeight = canvasHeight
	scroll.shouldRender = visibleRowsCountFractioned < entityCount
	scroll.containerHeight = maxScrollHeight
	scroll.containerWidth = scrollWidth
	scroll.containerLeft = 0
	scroll.containerTop = 0
	scroll.height = minScrollHeight + (maxScrollHeight - minScrollHeight) * (visibleRowsCount / entityCount)
	scroll.top = scroll.containerTop + (maxScrollHeight - scroll.height) * scroll.pos
	scroll.left = scroll.containerLeft + scrollContainerPadding
	scroll.right = scroll.left + scrollWidth - scrollContainerPadding*2
	scroll.bottom = scroll.top + scroll.height
	
	
	ctx.strokeStyle = "#ddd"
	//ctx.rect(0, 0, canvasWidth, canvasHeight)
	
	// draw scroll on the left!
	if (scroll.shouldRender) {
		ctx.lineWidth = r
		ctx.rect(scroll.containerLeft, scroll.containerTop, scroll.containerWidth, scroll.containerHeight)
		ctx.stroke()
		ctx.fillStyle = "#ccc"
		ctx.fillRect(scroll.left, scroll.top + scrollContainerPadding, scrollWidth - scrollContainerPadding*2, scroll.height - scrollContainerPadding*2)
		
		//ctx.fillStyle = "red"
		//ctx.fillRect(scroll.left, scroll.top + scroll.dragOffsetY, scrollWidth - scrollContainerPadding*2, 3)
	}

	// draw rows representing game entities!
	const fontSize = 13
	ctx.font = fontSize + "px monospace"
	ctx.strokeStyle = ctx.fillStyle = "black"
	ctx.lineWidth = r
	
	let firstEntityIndexWithTranslation = 0
	
	if (scroll.isDragged) {
		firstEntityIndexWithTranslation = (entityCount - Math.floor(visibleRowsCountFractioned) + visibleRowsCountFractioned % 1 - 1) * scroll.pos
	}
	else {
		firstEntityIndexWithTranslation = scroll.firstEntityIndexWithTranslation	
	}
	
	const firstEntityIndex = Math.floor(firstEntityIndexWithTranslation)
	const startX = scrollWidth + colsGap
	const idColWidth = 70*r
	const rowWidth = idColWidth + componentTypesCount * (crossSize+colsGap)
	
	y = -(firstEntityIndexWithTranslation % 1) * (rowHeight+rowsGap)
	
	
	let hoveringCol = -1
	
	// background for hovered column
	if (hover.lastMousePosX > 0)
	for (let x = startX + idColWidth, colIndex = 0; x < startX+rowWidth; x += crossSize + colsGap, colIndex += 1) {
		if (hover.lastMousePosX >= x - hoverMargin && hover.lastMousePosX <= x + crossSize + hoverMargin) {
			const oldFillStyle = ctx.fillStyle
			ctx.fillStyle = "#f9f9f9"
			ctx.fillRect(x - hoverMargin, 0, crossSize + 2*hoverMargin, canvasHeight)
			ctx.fillStyle = oldFillStyle
			hoveringCol = colIndex
			break
		}
	}
	
	for (let ei = 0, eiEnd = Math.min(visibleRowsCount, entityCount); ei < eiEnd; ++ei) {
		const entity = entityComponents[firstEntityIndex + ei]
		let x = startX

		// background for hovered row
		isRenderingRowHover = hover.lastMousePosY >= y - hoverMargin
			&& hover.lastMousePosY <= y + rowHeight + hoverMargin
			&& hover.lastMousePosX > startX
		if (isRenderingRowHover) {
			const oldFillStyle = ctx.fillStyle
			ctx.fillStyle = "#f3f3f3"
			ctx.fillRect(x - hoverMargin/2, y - hoverMargin/2 - 1.5, rowWidth + hoverMargin, rowHeight + hoverMargin)
			ctx.fillStyle = oldFillStyle
		}

		// entity id
		ctx.fillText((entity.entityId + "").padStart(5, " "), x, y + rowHeight - rowYPadding)
		x += idColWidth
		
		// component set
		for (let cmpIndex = 0; cmpIndex < componentTypesCount; ++cmpIndex, x += crossSize + colsGap) {
			if (entity.components[cmpIndex] == 1) {
				if (isRenderingRowHover && hoveringCol == cmpIndex) {
					const oldFillStyle = ctx.fillStyle
					const size = crossSize + hoverMargin*2
					ctx.fillStyle = "#ccc"
					ctx.fillRect(x - hoverMargin, y - hoverMargin, size, size)
					ctx.fillStyle = oldFillStyle
				}
			
				ctx.beginPath()
				ctx.moveTo(x, y)
				ctx.lineTo(x + crossSize, y + crossSize)
				ctx.moveTo(x + crossSize, y)
				ctx.lineTo(x, y + crossSize)
				ctx.stroke()
			}
		}
		
		y += rowHeight + rowsGap
	}
}
</script>